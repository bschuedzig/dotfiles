#   ____  ____   ___  _____ ___ _     _____
#  |  _ \|  _ \ / _ \|  ___|_ _| |   | ____|
#  | |_) | |_) | | | | |_   | || |   |  _|
#  |  __/|  _ <| |_| |  _|  | || |___| |___
#  |_|   |_| \_\\___/|_|   |___|_____|_____|
#

#
# For startup time debugging, enable the next line:
#
#PS4=$'+ %D{%s.%6.} %N:%i> '
#
# and execute this:
#
#zsh -lx 2>zsh-startup.log
#
# after that finishes, execute "exit"

#   _________  _   _
#  |__  / ___|| | | |
#    / /\___ \| |_| |
#   / /_ ___) |  _  |
#  /____|____/|_| |_|
#

export ZSH=$HOME/.oh-my-zsh
export ZSH_CUSTOM=$HOME/.oh-my-zsh-custom
plugins=(autojump sudo docker zsh-autosuggestions)

ZSH_THEME="bullet-train"
BULLETTRAIN_STATUS_EXIT_SHOW=true

COMPLETION_WAITING_DOTS="true"

source $ZSH/oh-my-zsh.sh

export HISTFILE=~/.zsh_history    # ensure history file visibility
export HH_CONFIG=hicolor,keywords # get more colors
bindkey -s "\C-r" "\eqhh\n"       # bind hh to Ctrl-r (for Vi mode check doc)

export NNN_TMPFILE="/tmp/nnn"

n() {
	nnn "$@"

	if [ -f $NNN_TMPFILE ]; then
		. $NNN_TMPFILE
		rm $NNN_TMPFILE
	fi
}
bindkey -s "\C-q" "\eqn\n"

# Just writing "." will reload zshrc
function _accept-line() {
	if [[ $BUFFER == "." ]]; then
		BUFFER="source ~/.zshrc"
	fi
	zle .accept-line
}

zle -N accept-line _accept-line

#export JAVA_HOME=$(/usr/libexec/java_home)

#      _    _     ___    _    ____  _____ ____
#     / \  | |   |_ _|  / \  / ___|| ____/ ___|
#    / _ \ | |    | |  / _ \ \___ \|  _| \___ \
#   / ___ \| |___ | | / ___ \ ___) | |___ ___) |
#  /_/   \_\_____|___/_/   \_\____/|_____|____/
#

alias ..="cd .."
alias dir="ls -lAG"
alias cd..="cd .."
alias kc="kubectl"
alias k="kubectl"

# Depends on the mood. repeats the last command with prepended "sudo"
alias please='sudo $(fc -nl -1)'
alias fuck='sudo $(fc -nl -1)'

alias pm2="node_modules/.bin/pm2"

# Keep a list of all SSH targets in "~/.ssh_targets"
function ssh_connect() {

	FILE="$HOME/.ssh_targets"
	TEMP_FILE="$HOME/.ssh_temp"

	# If just "ssh" is entered, list them (merged with ssh entries from ~/.zsh_history)
	if [ "$#" -eq 0 ]; then
		# first take the file generated by this command
		cat $FILE >$TEMP_FILE
		# add a new line at the end
		printf "\n" >>$TEMP_FILE
		# filter all ssh entries from the .zsh_history file and add them as well
		cat ~/.zsh_history | grep ":0;sscc" >>$TEMP_FILE
		# invoke hh with that file
		HISTFILE=$TEMP_FILE hh
		return 0
	fi

	LINE="ssh $@"
	/usr/bin/ssh "$@"

	# only save it if the connection was sucessful
	if [ $? -eq 0 ]; then
		# add it if it does not exist already
		grep -q -F "$LINE" $FILE || echo ": $(date +%s):0;$LINE" >>$FILE
	fi

}
alias ssh="ssh_connect"

#   ____   _  _____ _   _ ____
#  |  _ \ / \|_   _| | | / ___|
#  | |_) / _ \ | | | |_| \___ \
#  |  __/ ___ \| | |  _  |___) |
#  |_| /_/   \_\_| |_| |_|____/
#

export PATH="$PATH:/usr/local/Cellar/solr/5.1.0/libexec/bin"
export PATH="$PATH:/bin"
export PATH="$PATH:/sbin"
export PATH="$PATH:/usr/bin"
export PATH="$PATH:/usr/sbin"
export PATH="$PATH:/usr/local/bin"
export PATH="$PATH:/usr/local/sbin"
export PATH="$PATH:/usr/local/bin"
export PATH="$PATH:/usr/local/opt/inetutils/libexec/gnubin"
export PATH="$PATH:/opt/X11/bin"
export PATH="$PATH:/Users/ben/bin"
export PATH="$PATH:/opt/etcher-cli"
export PATH="$HOME/.yarn/bin:$PATH"
export PATH="$PATH:/usr/local/opt/inetutils/libexec/gnubin"
export PATH="$PATH:/Users/ben/Library/Android/sdk/platform-tools/"
export PATH="$PATH:/Users/ben/Library/Android/sdk/emulator"
export PATH="$PATH:/Users/ben/.local/bin"
export GOOGLE_APPLICATION_CREDENTIALS="/Users/ben/.google/werkerapp.json"

export GOPATH="$HOME/go"
export PATH="$PATH:$GOPATH/bin"

export ANDROID_HOME="/Users/ben/Library/Android/sdk"
export ANDROID_TOOLS="/Users/ben/Library/Android/sdk/tools/"
export ANDROID_PLATFORM_TOOLS="/Users/ben/Library/Android/sdk/platform-tools/"
export PATH=$PATH:$ANDROID_HOME:$ANDROID_TOOLS:$ANDROID_PLATFORM_TOOLS

export PATH="$PATH:/Users/ben/git/emscripten-core/emsdk:/Users/ben/git/emscripten-core/emsdk/fastcomp/emscripten"

#   _   _ _____ ___ _     ___ _____ ___ _____ ____
#  | | | |_   _|_ _| |   |_ _|_   _|_ _| ____/ ___|
#  | | | | | |  | || |    | |  | |  | ||  _| \___ \
#  | |_| | | |  | || |___ | |  | |  | || |___ ___) |
#   \___/  |_| |___|_____|___| |_| |___|_____|____/
#

# Expects standard AWS configurations in ~/.aws
# Lists all configurations (if invoked without parameter)
# Will update AWS_PROFILE if invoked with a parameter
awsprofile() {

	PROFILES=$(cat ~/.aws/config | grep "\[" | awk -F']' '{print $1}' | awk -F'[' '{print $2}' | grep '.')
	if [[ -z "$1" ]]; then
		echo $PROFILES
	else
		TEMP=$(echo "$PROFILES" | grep "$1")
		[[ -z "$TEMP" ]] && echo "Profile does not exist" && return 1
		export AWS_PROFILE=$1
		echo "AWS_PROFILE set to $1"
	fi

}

kubeconfig() {
	local KUBEDIR="$HOME/.kube"

	export KUBECONFIG=$(find $KUBEDIR -maxdepth 1 -type f -exec realpath {} \; | grep -v "kubectx$" | grep -v ".gitignore" | sort | paste -s -d: -)
	echo "KUBECONFIG=$KUBECONFIG"
}

# Execute it right away
kubeconfig >/dev/null

herokuapp() {

	if [[ -z "$1" ]]; then
		ls -1 ~/.heroku
		return 0
	fi

	APP="$HOME/.heroku/$1"

	if [ ! -e $APP ]; then
		echo "$APP does not exist"
	else
		export HEROKU_APP=$1
		echo "HEROKU_APP set to $1"
	fi
}

herokuapps() {
	herokuapp "$1"
}

dockerhost() {
	if [[ -z "$1" ]]; then
		echo DOCKER_HOST=$DOCKER_HOST
		echo
		echo "dockerhost <new-docker-host>"
		echo
	else
		echo Setting DOCKER_HOST=$1
		export DOCKER_HOST=$1
	fi
}

gitroot() {
	cd $(git rev-parse --show-toplevel)
}

gt() {
	cd $(git rev-parse --show-toplevel)
}

cdf() {

	target=$(osascript -e 'tell application "Finder" to if (count of Finder windows) > 0 then get POSIX path of (target of front Finder window as text)')
	if [ "$target" != "" ]; then
		cd "$target"
		pwd
	else
		echo 'No Finder window found' >&2
	fi
}

#   _   _ _   _ ____   ___  ____ _____ _____ ____
#  | | | | \ | / ___| / _ \|  _ \_   _| ____|  _ \
#  | | | |  \| \___ \| | | | |_) || | |  _| | | | |
#  | |_| | |\  |___) | |_| |  _ < | | | |___| |_| |
#   \___/|_| \_|____/ \___/|_| \_\|_| |_____|____/
#

test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

export CLICOLOR=1
export LSCOLORS=ExFxCxDxBxegedabagacad

setopt no_rm_star_silent

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"                           # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion" # This loads nvm bash_completion

export HOMEBREW_BREWFILE="/Users/ben/Dropbox (Personal)/config/Brewfile"

if [ -f $(brew --prefix)/etc/brew-wrap ]; then
	source $(brew --prefix)/etc/brew-wrap
fi

source ~/.zshrc.local
export PYENV_VERSION=3.6.0
eval "$(pyenv init -)"

export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8

[ -s "/Users/ben/.jabba/jabba.sh" ] && source "/Users/ben/.jabba/jabba.sh"

# The next line updates PATH for the Google Cloud SDK.
if [ -f '/Users/ben/google-cloud-sdk/path.zsh.inc' ]; then . '/Users/ben/google-cloud-sdk/path.zsh.inc'; fi

# The next line enables shell command completion for gcloud.
if [ -f '/Users/ben/google-cloud-sdk/completion.zsh.inc' ]; then . '/Users/ben/google-cloud-sdk/completion.zsh.inc'; fi

alias giit='git'

export GPG_TTY=$(tty)
